import * as path from 'path';
import { promises as fs } from 'fs';
import * as FileSystemUtils from './core/FileSystemUtils';
import { loadConfig } from './core/ConfigLoader';
import { IAgent } from './agents/IAgent';
import { CopilotAgent } from './agents/CopilotAgent';
import { ClaudeAgent } from './agents/ClaudeAgent';
import { CodexCliAgent } from './agents/CodexCliAgent';
import { CursorAgent } from './agents/CursorAgent';
import { WindsurfAgent } from './agents/WindsurfAgent';
import * as ClineAgent from './agents/ClineAgent';
import { AiderAgent } from './agents/AiderAgent';
import { FirebaseAgent } from './agents/FirebaseAgent';
import { OpenHandsAgent } from './agents/OpenHandsAgent';
import { GeminiCliAgent } from './agents/GeminiCliAgent';
import { JulesAgent } from './agents/JulesAgent';
import { JunieAgent } from './agents/JunieAgent';
import { AugmentCodeAgent } from './agents/AugmentCodeAgent';
import { getNativeMcpPath } from './paths/mcp';
import { IAgentConfig } from './agents/IAgent';
import { createRulerError, logVerbose } from './constants';

const agents: IAgent[] = [
  new CopilotAgent(),
  new ClaudeAgent(),
  new CodexCliAgent(),
  new CursorAgent(),
  new WindsurfAgent(),
  new ClineAgent.ClineAgent(),
  new AiderAgent(),
  new FirebaseAgent(),
  new OpenHandsAgent(),
  new GeminiCliAgent(),
  new JulesAgent(),
  new JunieAgent(),
  new AugmentCodeAgent(),
];

/**
 * Gets all output paths for an agent, taking into account any config overrides.
 * This is a copy of the function from lib.ts to maintain consistency.
 */
function getAgentOutputPaths(
  agent: IAgent,
  projectRoot: string,
  agentConfig?: IAgentConfig,
): string[] {
  const paths: string[] = [];
  const defaults = agent.getDefaultOutputPath(projectRoot);

  if (typeof defaults === 'string') {
    const actualPath = agentConfig?.outputPath ?? defaults;
    paths.push(actualPath);
  } else {
    const defaultPaths = defaults as Record<string, string>;

    if ('instructions' in defaultPaths) {
      const instructionsPath =
        agentConfig?.outputPathInstructions ?? defaultPaths.instructions;
      paths.push(instructionsPath);
    }

    if ('config' in defaultPaths) {
      const configPath = agentConfig?.outputPathConfig ?? defaultPaths.config;
      paths.push(configPath);
    }

    for (const [key, defaultPath] of Object.entries(defaultPaths)) {
      if (key !== 'instructions' && key !== 'config') {
        paths.push(defaultPath);
      }
    }
  }

  return paths;
}

/**
 * Checks if a file exists.
 */
async function fileExists(filePath: string): Promise<boolean> {
  try {
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Restores a file from its backup if the backup exists.
 */
async function restoreFromBackup(
  filePath: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const backupPath = `${filePath}.bak`;
  const backupExists = await fileExists(backupPath);

  if (!backupExists) {
    logVerbose(`No backup found for: ${filePath}`, verbose);
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would restore: ${filePath} from backup`,
      verbose,
    );
  } else {
    await fs.copyFile(backupPath, filePath);
    logVerbose(`${actionPrefix} Restored: ${filePath} from backup`, verbose);
  }

  return true;
}

/**
 * Removes a file if it exists and has no backup (meaning it was generated by ruler).
 */
async function removeGeneratedFile(
  filePath: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const fileExistsFlag = await fileExists(filePath);
  const backupExists = await fileExists(`${filePath}.bak`);

  if (!fileExistsFlag) {
    logVerbose(`File does not exist: ${filePath}`, verbose);
    return false;
  }

  if (backupExists) {
    logVerbose(`File has backup, skipping removal: ${filePath}`, verbose);
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove generated file: ${filePath}`,
      verbose,
    );
  } else {
    await fs.unlink(filePath);
    logVerbose(`${actionPrefix} Removed generated file: ${filePath}`, verbose);
  }

  return true;
}

/**
 * Removes backup files.
 */
async function removeBackupFile(
  filePath: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const backupPath = `${filePath}.bak`;
  const backupExists = await fileExists(backupPath);

  if (!backupExists) {
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove backup file: ${backupPath}`,
      verbose,
    );
  } else {
    await fs.unlink(backupPath);
    logVerbose(`${actionPrefix} Removed backup file: ${backupPath}`, verbose);
  }

  return true;
}

/**
 * Removes empty directories that were created by ruler.
 * Only removes directories if they are empty and were likely created by ruler.
 */
async function removeEmptyDirectories(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<number> {
  const rulerCreatedDirs = [
    '.github',
    '.cursor',
    '.windsurf',
    '.junie',
    '.openhands',
    '.idx',
    '.gemini',
    '.vscode',
    '.augmentcode',
  ];

  let directoriesRemoved = 0;
  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  for (const dirName of rulerCreatedDirs) {
    const dirPath = path.join(projectRoot, dirName);

    try {
      const stat = await fs.stat(dirPath);
      if (!stat.isDirectory()) {
        continue;
      }

      const entries = await fs.readdir(dirPath);
      if (entries.length === 0) {
        if (dryRun) {
          logVerbose(
            `${actionPrefix} Would remove empty directory: ${dirPath}`,
            verbose,
          );
        } else {
          await fs.rmdir(dirPath);
          logVerbose(
            `${actionPrefix} Removed empty directory: ${dirPath}`,
            verbose,
          );
        }
        directoriesRemoved++;
      } else {
        let hasNonEmptyContent = false;
        for (const entry of entries) {
          const entryPath = path.join(dirPath, entry);
          const entryStat = await fs.stat(entryPath);
          if (entryStat.isFile()) {
            hasNonEmptyContent = true;
            break;
          } else if (entryStat.isDirectory()) {
            const subEntries = await fs.readdir(entryPath);
            if (subEntries.length > 0) {
              hasNonEmptyContent = true;
              break;
            }
          }
        }

        if (!hasNonEmptyContent) {
          if (dryRun) {
            logVerbose(
              `${actionPrefix} Would remove directory tree: ${dirPath}`,
              verbose,
            );
          } else {
            await fs.rm(dirPath, { recursive: true });
            logVerbose(
              `${actionPrefix} Removed directory tree: ${dirPath}`,
              verbose,
            );
          }
          directoriesRemoved++;
        }
      }
    } catch {
      logVerbose(
        `Directory ${dirPath} doesn't exist or can't be accessed`,
        verbose,
      );
    }
  }

  return directoriesRemoved;
}

/**
 * Removes additional files created by specific agents that aren't covered by their main output paths.
 */
async function removeAdditionalAgentFiles(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<number> {
  const additionalFiles = [
    '.gemini/settings.json',
    'claude_desktop_config.json',
    '.mcp.json',
    '.vscode/mcp.json',
    '.cursor/mcp.json',
    '.openhands/config.toml',
    '.augmentcode/config.json',
  ];

  let filesRemoved = 0;
  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  for (const filePath of additionalFiles) {
    const fullPath = path.join(projectRoot, filePath);

    try {
      const fileExistsFlag = await fileExists(fullPath);
      if (!fileExistsFlag) {
        continue;
      }

      const backupExists = await fileExists(`${fullPath}.bak`);
      if (backupExists) {
        const restored = await restoreFromBackup(fullPath, verbose, dryRun);
        if (restored) {
          filesRemoved++;
        }
      } else {
        if (dryRun) {
          logVerbose(
            `${actionPrefix} Would remove additional file: ${fullPath}`,
            verbose,
          );
        } else {
          await fs.unlink(fullPath);
          logVerbose(
            `${actionPrefix} Removed additional file: ${fullPath}`,
            verbose,
          );
        }
        filesRemoved++;
      }
    } catch {
      logVerbose(
        `Additional file ${fullPath} doesn't exist or can't be accessed`,
        verbose,
      );
    }
  }

  return filesRemoved;
}

/**
 * Removes the ruler-managed block from .gitignore file.
 */
async function cleanGitignore(
  projectRoot: string,
  verbose: boolean,
  dryRun: boolean,
): Promise<boolean> {
  const gitignorePath = path.join(projectRoot, '.gitignore');
  const gitignoreExists = await fileExists(gitignorePath);

  if (!gitignoreExists) {
    logVerbose('No .gitignore file found', verbose);
    return false;
  }

  const content = await fs.readFile(gitignorePath, 'utf8');
  const startMarker = '# START Ruler Generated Files';
  const endMarker = '# END Ruler Generated Files';

  const startIndex = content.indexOf(startMarker);
  const endIndex = content.indexOf(endMarker);

  if (startIndex === -1 || endIndex === -1) {
    logVerbose('No ruler-managed block found in .gitignore', verbose);
    return false;
  }

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    logVerbose(
      `${actionPrefix} Would remove ruler block from .gitignore`,
      verbose,
    );
  } else {
    const beforeBlock = content.substring(0, startIndex);
    const afterBlock = content.substring(endIndex + endMarker.length);

    let newContent = beforeBlock + afterBlock;
    newContent = newContent.replace(/\n{3,}/g, '\n\n'); // Replace 3+ newlines with 2

    if (newContent.trim() === '') {
      await fs.unlink(gitignorePath);
      logVerbose(`${actionPrefix} Removed empty .gitignore file`, verbose);
    } else {
      await fs.writeFile(gitignorePath, newContent);
      logVerbose(
        `${actionPrefix} Removed ruler block from .gitignore`,
        verbose,
      );
    }
  }

  return true;
}

/**
 * Reverts ruler configurations for selected AI agents.
 */
export async function revertAllAgentConfigs(
  projectRoot: string,
  includedAgents?: string[],
  configPath?: string,
  keepBackups = false,
  verbose = false,
  dryRun = false,
  localOnly = false,
): Promise<void> {
  logVerbose(
    `Loading configuration for revert from project root: ${projectRoot}`,
    verbose,
  );

  const config = await loadConfig({
    projectRoot,
    cliAgents: includedAgents,
    configPath,
  });

  const rulerDir = await FileSystemUtils.findRulerDir(projectRoot, !localOnly);
  if (!rulerDir) {
    throw createRulerError(
      `.ruler directory not found`,
      `Searched from: ${projectRoot}`,
    );
  }
  logVerbose(`Found .ruler directory at: ${rulerDir}`, verbose);

  const rawConfigs = config.agentConfigs;
  const mappedConfigs: Record<string, (typeof rawConfigs)[string]> = {};
  for (const [key, cfg] of Object.entries(rawConfigs)) {
    const lowerKey = key.toLowerCase();
    for (const agent of agents) {
      const identifier = agent.getIdentifier();
      if (
        identifier === lowerKey ||
        agent.getName().toLowerCase().includes(lowerKey)
      ) {
        mappedConfigs[identifier] = cfg;
      }
    }
  }
  config.agentConfigs = mappedConfigs;

  let selected = agents;
  if (config.cliAgents && config.cliAgents.length > 0) {
    const filters = config.cliAgents.map((n) => n.toLowerCase());
    selected = agents.filter((agent) =>
      filters.some(
        (f) =>
          agent.getIdentifier() === f ||
          agent.getName().toLowerCase().includes(f),
      ),
    );
    logVerbose(
      `Selected agents via CLI filter: ${selected.map((a) => a.getName()).join(', ')}`,
      verbose,
    );
  } else if (config.defaultAgents && config.defaultAgents.length > 0) {
    const defaults = config.defaultAgents.map((n) => n.toLowerCase());
    selected = agents.filter((agent) => {
      const identifier = agent.getIdentifier();
      const override = config.agentConfigs[identifier]?.enabled;
      if (override !== undefined) {
        return override;
      }
      return defaults.some(
        (d) => identifier === d || agent.getName().toLowerCase().includes(d),
      );
    });
    logVerbose(
      `Selected agents via config default_agents: ${selected.map((a) => a.getName()).join(', ')}`,
      verbose,
    );
  } else {
    selected = agents.filter(
      (agent) => config.agentConfigs[agent.getIdentifier()]?.enabled !== false,
    );
    logVerbose(
      `Selected all enabled agents: ${selected.map((a) => a.getName()).join(', ')}`,
      verbose,
    );
  }

  let totalFilesProcessed = 0;
  let totalFilesRestored = 0;
  let totalFilesRemoved = 0;
  let totalBackupsRemoved = 0;

  for (const agent of selected) {
    const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';
    console.log(`${actionPrefix} Reverting ${agent.getName()}...`);

    const agentConfig = config.agentConfigs[agent.getIdentifier()];
    const outputPaths = getAgentOutputPaths(agent, projectRoot, agentConfig);

    logVerbose(
      `Agent ${agent.getName()} output paths: ${outputPaths.join(', ')}`,
      verbose,
    );

    for (const outputPath of outputPaths) {
      totalFilesProcessed++;

      const restored = await restoreFromBackup(outputPath, verbose, dryRun);
      if (restored) {
        totalFilesRestored++;

        if (!keepBackups) {
          const backupRemoved = await removeBackupFile(
            outputPath,
            verbose,
            dryRun,
          );
          if (backupRemoved) {
            totalBackupsRemoved++;
          }
        }
      } else {
        const removed = await removeGeneratedFile(outputPath, verbose, dryRun);
        if (removed) {
          totalFilesRemoved++;
        }
      }
    }

    const mcpPath = await getNativeMcpPath(agent.getName(), projectRoot);
    if (mcpPath && mcpPath.startsWith(projectRoot)) {
      totalFilesProcessed++;

      const mcpRestored = await restoreFromBackup(mcpPath, verbose, dryRun);
      if (mcpRestored) {
        totalFilesRestored++;

        if (!keepBackups) {
          const mcpBackupRemoved = await removeBackupFile(
            mcpPath,
            verbose,
            dryRun,
          );
          if (mcpBackupRemoved) {
            totalBackupsRemoved++;
          }
        }
      } else {
        const mcpRemoved = await removeGeneratedFile(mcpPath, verbose, dryRun);
        if (mcpRemoved) {
          totalFilesRemoved++;
        }
      }
    }
  }

  const gitignoreCleaned =
    !config.cliAgents || config.cliAgents.length === 0
      ? await cleanGitignore(projectRoot, verbose, dryRun)
      : false;

  const additionalFilesRemoved = await removeAdditionalAgentFiles(
    projectRoot,
    verbose,
    dryRun,
  );
  totalFilesRemoved += additionalFilesRemoved;

  const directoriesRemoved = await removeEmptyDirectories(
    projectRoot,
    verbose,
    dryRun,
  );

  const actionPrefix = dryRun ? '[ruler:dry-run]' : '[ruler]';

  if (dryRun) {
    console.log(`${actionPrefix} Revert summary (dry run):`);
  } else {
    console.log(`${actionPrefix} Revert completed successfully.`);
  }

  console.log(`  Files processed: ${totalFilesProcessed}`);
  console.log(`  Files restored from backup: ${totalFilesRestored}`);
  console.log(`  Generated files removed: ${totalFilesRemoved}`);
  if (!keepBackups) {
    console.log(`  Backup files removed: ${totalBackupsRemoved}`);
  }
  if (directoriesRemoved > 0) {
    console.log(`  Empty directories removed: ${directoriesRemoved}`);
  }
  if (gitignoreCleaned) {
    console.log(`  .gitignore cleaned: yes`);
  }
}
